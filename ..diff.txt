diff --git a/02_install_python.sh b/02_install_python.sh
index 4716d1a..c90ecfe 100644
--- a/02_install_python.sh
+++ b/02_install_python.sh
@@ -1,3 +1,8 @@
+#!/bin/bash
+
 # Install Python 3 and pip
 echo "Installing Python3 and pip..."
-sudo apt-get install -y python3 python3-pip
\ No newline at end of file
+sudo apt-get install -y python3 python3-pip
+
+
+echo "All done!"
\ No newline at end of file
diff --git a/03_create_venv.sh b/03_create_venv.sh
index f0ba1fa..757a846 100644
--- a/03_create_venv.sh
+++ b/03_create_venv.sh
@@ -10,15 +10,8 @@ fi
 echo "Creating a virtual environment..."
 python3 -m venv venv
 
-
 # set exec permissions on activate
 echo "Set execute permissions on virtual environment activate..."
 chmod +x ./venv/bin/activate
 
-# Activate the virtual environment
-echo "Activating the virtual environment..."
-. venv/bin/activate
-
-# windows gitbash
-#source venv/Scripts/activate
 
diff --git a/activate_venv.sh b/04_activate_venv_CALL_BY_SOURCE.sh
similarity index 52%
rename from activate_venv.sh
rename to 04_activate_venv_CALL_BY_SOURCE.sh
index 1929f4c..b88133f 100644
--- a/activate_venv.sh
+++ b/04_activate_venv_CALL_BY_SOURCE.sh
@@ -1,16 +1,23 @@
 #!/bin/bash
 
+# to activate this outside of the script you need to call like this:
+
+# source ./activate_venv.sh 
+
 echo $VIRTUAL_ENV
 
-if [[ "$VIRTUAL_ENV" == ""]]
+if [[ "$VIRTUAL_ENV" == "" ]]
 then
     # Activate the virtual environment
     echo "Activating the virtual environment..."
     . venv/bin/activate
+
+    echo $VIRTUAL_ENV
 fi
 
-echo $VIRTUAL_ENV
 
+# linux
+# . venv/bin/activate
 
 # windows gitbash
 #source venv/Scripts/activate
diff --git a/04_install_python_dependencies.sh b/05_install_python_dependencies.sh
similarity index 100%
rename from 04_install_python_dependencies.sh
rename to 05_install_python_dependencies.sh
diff --git a/health_check.sh b/health_check.sh
index 1c167b9..02f3fbd 100644
--- a/health_check.sh
+++ b/health_check.sh
@@ -80,14 +80,14 @@ else
 fi
 
 
-# Install safety if not present
-echo -n "Checking if safety is installed: "
-if ! command -v safety &>/dev/null; then
-    echo "safety not found, installing..."
-    pip3 install safety
-else
-    echo "safety is installed."
-fi
+# # Install safety if not present
+# echo -n "Checking if safety is installed: "
+# if ! command -v safety &>/dev/null; then
+#     echo "safety not found, installing..."
+#     pip3 install safety
+# else
+#     echo "safety is installed."
+# fi
 
 # Check Python packages for known vulnerabilities
 echo "Checking installed Python packages for vulnerabilities..."
diff --git a/launch.json b/launch.json
new file mode 100644
index 0000000..46a66c7
--- /dev/null
+++ b/launch.json
@@ -0,0 +1,25 @@
+{
+  // Use IntelliSense to learn about possible attributes.
+  // Hover to view descriptions of existing attributes.
+  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
+  "version": "0.2.0",
+  "configurations": [
+
+      {
+          "name": "Python: Current File",
+          "type": "debugpy",
+          "request": "launch",
+          "program": "${file}",
+          "console": "integratedTerminal",
+          "justMyCode": true
+      },
+
+      {
+          "type": "bashdb",
+          "request": "launch",
+          "name": "Bash-Debug (simplest configuration)",
+          "program": "${file}",
+          "terminalKind": "integrated"
+      }
+  ]
+}
\ No newline at end of file
diff --git a/remote-debug-test.py b/remote-debug-test.py
new file mode 100644
index 0000000..c947a49
--- /dev/null
+++ b/remote-debug-test.py
@@ -0,0 +1,10 @@
+#import debugpy
+
+# 5678 is the default attach port in the VS Code debug configurations. Unless a host and port are specified, host defaults to 127.0.0.1
+#debugpy.listen(5678)
+#print("Waiting for debugger attach")
+#debugpy.wait_for_client()
+#debugpy.breakpoint()
+print('break on this line')
+print('break on this line')
+print('break on this line')
diff --git a/remote-debug-test.sh b/remote-debug-test.sh
new file mode 100644
index 0000000..16f5388
--- /dev/null
+++ b/remote-debug-test.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+echo "break on this line"
+echo "break on this line"
+echo "break on this line"
\ No newline at end of file
diff --git a/settings.ini b/settings.ini
deleted file mode 100644
index 92a8d58..0000000
--- a/settings.ini
+++ /dev/null
@@ -1,14 +0,0 @@
-[Paths]
-SourcePath=~/shuttlework/source
-DestinationPath=~/.shuttlework/destination
-QuarantinePath=~/.shuttlework/quarantine
-LogPath=~/shuttlework/logs
-HazardArchivePath=~/shuttlework/hazard_archive
-HazardEncryptionKeyPath = /path/to/shuttle_hazard_public.gpg
-
-[Settings]
-MaxScans=4
-DeleteSourceFilesAfterCopying=True 
-
-[Logging]
-LogLevel=INFO
\ No newline at end of file
diff --git a/setup_test_environment_linux.py b/setup_test_environment_linux.py
index aa970a1..af757cd 100644
--- a/setup_test_environment_linux.py
+++ b/setup_test_environment_linux.py
@@ -1,20 +1,23 @@
+#!/home/dav717/.venv/bin/python3
+
 import os
 import random
 import string
 import configparser  # Added import for configparser
+import subprocess
 
 # Define directories
-base_dir = os.path.expanduser("~/")
-work_dir = os.path.expanduser("shuttlework/")
-source_dir = os.path.join(base_dir, work_dir, "source")
-quarantine_dir = os.path.join(base_dir, work_dir, "quarantine")
-dest_dir = os.path.join(base_dir, work_dir, "destination")
-log_dir = os.path.join(base_dir, work_dir, "logs")
-settings_dir = os.path.join(base_dir, ".shuttle")
-hazard_archive_dir = os.path.join(base_dir, work_dir, "HazardArchive")
-hazard_encryption_key_path = os.path.join(base_dir, work_dir, "shuttle_hazard_public.gpg")
 
+work_dir = os.path.expanduser("~/shuttlework/")
+source_dir = os.path.join(work_dir, "source")
+quarantine_dir = os.path.join(work_dir, "quarantine")
+dest_dir = os.path.join(work_dir, "destination")
+log_dir = os.path.join(work_dir, "logs")
+hazard_archive_dir = os.path.join(work_dir, "hazard")
+
+settings_dir = os.path.expanduser("~/.shuttle")
 settings_file = os.path.join(settings_dir, "settings.ini")
+hazard_encryption_key_path = os.path.join(settings_dir, "hazard_public.gpg")
 
 # Create directories if they don't exist
 os.makedirs(source_dir, exist_ok=True)
@@ -24,6 +27,11 @@ os.makedirs(log_dir, exist_ok=True)
 os.makedirs(settings_dir, exist_ok=True)
 os.makedirs(hazard_archive_dir, exist_ok=True)
 
+inner_dir = os.path.join(source_dir, 'inner/') 
+
+# Create quarantine directory if it doesn't exist
+os.makedirs(inner_dir, exist_ok=True)
+
 # Function to generate random content
 def get_random_content(length=1000):
     return ''.join(random.choices(string.ascii_letters, k=length))
@@ -35,30 +43,61 @@ for filename in ['a.txt', 'b.txt', 'c.txt']:
     with open(file_path, 'w') as file:
         file.write(content)
 
+
+for filename in ['d.txt', 'e.txt', 'f.txt']:
+    file_path = os.path.join(inner_dir, filename)
+    content = get_random_content()
+    with open(file_path, 'w') as file:
+        file.write(content)
+
 # Create settings file using configparser
 config = configparser.ConfigParser()
 
-config['Paths'] = {
-    'SourcePath': source_dir,
-    'DestinationPath': dest_dir,
-    'QuarantinePath': quarantine_dir,
-    'LogPath': log_dir,
-    'QuarantineHazardArchive': hazard_archive_dir,
-    'HazardEncryptionKeyPath': hazard_encryption_key_path
+config['paths'] = {
+    'source_path': source_dir,
+    'destination_path': dest_dir,
+    'quarantine_path': quarantine_dir,
+    'log_path': log_dir,
+    'hazard_archive_path': hazard_archive_dir,
+    'hazard_encryption_key_path': hazard_encryption_key_path
 }
 
-config['Settings'] = {
-    'MaxScans': '4',
-    'DeleteSourceFilesAfterCopying': 'True'
+config['settings'] = {
+    'max_scan_threads': '1',
+    'delete_source_files_after_copying': 'True'
 }
 
-config['Logging'] = {
-    'LogLevel': 'DEBUG'
+config['logging'] = {
+    'log_level': 'DEBUG'
 }
 
 with open(settings_file, 'w') as configfile:
     config.write(configfile)
 
+
+    result = subprocess.run(
+        [
+            "mdatp",
+            "exclusion",
+            "folder",
+            "add",
+            "--path",
+            work_dir,
+            "--scope",
+            "global"
+        ],
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+        text=True,
+        check=False
+    )
+
+    print(result.stderr)
+    print(result.stdout)
+
+    if result.returncode == 0:
+        print("Work folder excluded from automatic malware scan: {work_dir}")
+    
 # Output messages
 print("Test environment setup complete:")
 print(f"Source directory: {source_dir}")
diff --git a/shuttle-linux.py b/shuttle-linux.py
index 6a752f8..f5b4a10 100644
--- a/shuttle-linux.py
+++ b/shuttle-linux.py
@@ -226,7 +226,6 @@ def is_file_stable(file_path, stability_time=5):
         logger.error(f"Error checking if file is stable {file_path}: {e}")
         return False
 
-
 def scan_and_process_file(args):
     """
     Scan a file for malware and process it accordingly.
@@ -262,7 +261,7 @@ def scan_and_process_file(args):
             [
                 "mdatp",
                 "scan",
-                "file",
+                "custom",
                 "--path",
                 quarantine_file_path
             ],
@@ -303,7 +302,6 @@ def scan_and_process_file(args):
         logger.error(f"An exception occurred while scanning {quarantine_file_path}: {e}")
         return False
 
-
 def handle_clean_file(
     quarantine_file_path,
     source_file_path,
@@ -320,43 +318,41 @@ def handle_clean_file(
         delete_source_files (bool): Whether to delete source files after processing
 
     Returns:
-        bool: True if the file was successfully handled, False otherwise
+        bool: True if the file was successfully handled, False
+          otherwise
     """
+    
     logger = logging.getLogger('shuttle')
     try:
-        # Create destination directory if it doesn't exist
-        dest_dir = os.path.dirname(destination_file_path)
-        try:
-            os.makedirs(dest_dir, exist_ok=True)
-        except PermissionError:
-            logger.error(f"Permission denied creating directory: {dest_dir}")
-            return False
-        except OSError as e:
-            logger.error(f"Failed to create directory {dest_dir}: {e}")
-            return False
+        copy_temp_then_rename(quarantine_file_path, destination_file_path)
 
-        # Move file to destination
-        shutil.move(quarantine_file_path, destination_file_path)
-        logger.info(f"Moved clean file to destination: {destination_file_path}")
+    except Exception as e:
+        logger.error(f"Failed to copy clean file from {quarantine_file_path} to {destination_file_path}: {e}")
+        return False
+    
+    if delete_source_files:
+        try:
 
-        # Verify integrity and delete source if requested
-        if delete_source_files:
+            # Verify integrity and delete source if requested
             if verify_file_integrity(source_file_path, destination_file_path):
                 remove_file_with_logging(source_file_path)
             else:
                 logger.error(f"Integrity check failed, source file not deleted: {source_file_path}")
                 return False
-
-        return True
-    except FileNotFoundError as e:
-        logger.error(f"File not found during handling of clean file: {e}")
-        return False
-    except PermissionError as e:
-        logger.error(f"Permission denied during handling of clean file: {e}")
-        return False
-    except Exception as e:
-        logger.error(f"Failed to handle clean file {quarantine_file_path}: {e}")
-        return False
+  
+        except FileNotFoundError as e:
+            logger.error(f"File not found during handling of clean file: {e}")
+            return False
+        
+        except PermissionError as e:
+            logger.error(f"Permission denied during handling of clean file: {e}")
+            return False
+        
+        except Exception as e:
+            logger.error(f"Failed to handle clean file {quarantine_file_path}: {e}")
+            return False
+        
+    return True
 
 def verify_file_integrity(source_file_path, comparison_file_path):
     """Verify file integrity between source and destination."""
@@ -383,7 +379,6 @@ def verify_file_integrity(source_file_path, comparison_file_path):
         logger.error(f"File integrity check failed between {source_file_path} and {comparison_file_path}")
         return False
 
-
 def encrypt_file(file_path, output_path, key_file_path):
     """
     Encrypt a file using GPG with a specified public key file.
@@ -480,48 +475,236 @@ def handle_suspect_file(
             archive_path = os.path.join(hazard_archive_path, archive_name)
 
             # Attempt to encrypt the file
-            if encrypt_file(quarantine_file_path, archive_path, key_file_path):
-                logger.info(f"Successfully encrypted suspect file to: {archive_path}")
-                
-                # Remove the infected file from quarantine
-                if not remove_file_with_logging(quarantine_file_path):
-                    logger.error(f"Failed to remove quarantined file after archiving: {quarantine_file_path}")
-                    return False
-                
-                # Delete source file if requested
-                if delete_source_files:
-                    if not remove_file_with_logging(source_file_path):
-                        logger.error(f"Failed to remove source file after archiving: {source_file_path}")
-                        return False
-                
-                return True
-            else:
+            if not encrypt_file(quarantine_file_path, archive_path, key_file_path):
                 logger.error(f"Failed to encrypt file: {quarantine_file_path}")
-                return False
+                return False 
+            
+            logger.info(f"Successfully encrypted suspect file to: {archive_path}")
+           
         else:
             # No hazard archive parameters - delete the infected file
             logger.warning(
                 f"No hazard archive path or encryption key file provided. "
                 f"Deleting infected file: {quarantine_file_path}"
             )
+
+        # Remove the infected file from quarantine
+        if not remove_file_with_logging(quarantine_file_path):
+            logger.error(f"Failed to remove quarantined file after archiving: {quarantine_file_path}")
+            return False
             
-            # Remove from quarantine
-            if not remove_file_with_logging(quarantine_file_path):
-                logger.error(f"Failed to remove quarantined file: {quarantine_file_path}")
+        # Delete source file if requested
+        if delete_source_files:
+            if not remove_file_with_logging(source_file_path):
+                logger.error(f"Failed to remove source file after archiving: {source_file_path}")
                 return False
-            
-            # Delete source if requested
-            if delete_source_files:
-                if not remove_file_with_logging(source_file_path):
-                    logger.error(f"Failed to remove source file: {source_file_path}")
-                    return False
-            
-            return True
+        
+        return True
 
     except Exception as e:
         logger.error(f"Unexpected error handling suspect file {quarantine_file_path}: {e}")
         return False
     
+def copy_temp_then_rename(from_path, to_path):
+
+    logger = logging.getLogger('shuttle')
+    to_dir = os.path.dirname(to_path)
+    to_path_temp = os.path.join(to_path + '.copying')
+    
+    try:        
+        os.makedirs(to_dir, exist_ok=True)
+
+        if os.path.exists(to_path_temp):
+            os.remove(to_path_temp)
+
+        shutil.copy2(from_path, to_path_temp)
+        os.rename(to_path_temp, to_path)
+
+        logger.info(f"Copied file {from_path} to : {to_path}")
+
+    except FileNotFoundError as e:
+        logger.error(f"File not found during copying: {from_path} to: {to_path}. Error: {e}")
+        raise
+
+    except PermissionError as e:
+        logger.error(f"Permission denied when copying file: {from_path} to: {to_path}. Error: {e}")
+        raise
+
+    except Exception as e:
+        logger.error(f"Failed to copy file: {from_path} to : {to_path}. Error: {e}")
+        raise
+
+    finally:
+        if os.path.exists(to_path_temp):
+            os.remove(to_path_temp)
+
+def normalize_path(path):
+    p = Path(path)
+    return str(p.parent.resolve().joinpath(p.name))
+
+def scan_and_process_directory(
+    source_path,
+    destination_path,
+    quarantine_path,
+    hazard_archive_path,
+    hazard_encryption_key_file_path,
+    delete_source_files,
+    max_scan_threads
+    ):
+   
+    quarantine_files = []
+
+    logger = logging.getLogger('shuttle')
+
+    try:
+        # Create quarantine directory if it doesn't exist
+        os.makedirs(quarantine_path, exist_ok=True)
+
+        # Copy files from source to quarantine directory
+        # os.walk traverses the directory tree
+        for source_root, dirs, source_files in os.walk(source_path, topdown=False):
+            for source_file in source_files:
+                source_file_path = os.path.join(source_root, source_file)
+
+                # Skip files that are not stable (still being written to)
+                if not is_file_stable(source_file_path):
+                    print(f"Skipping file {source_file_path} because it may still be written to.")
+                    continue  # Skip this file and proceed to the next one
+
+                # Skip files that are currently open
+                if is_file_open(source_file_path):
+                    print(f"Skipping file {source_file_path} because it is being written to.")
+                    continue  # Skip this file and proceed to the next one
+
+                # Determine the relative directory structure
+                # Replicate that structure in the quarantine directory
+                rel_dir = os.path.relpath(source_root, source_path)
+                quarantine_file_copy_dir = os.path.join(normalize_path(os.path.join(quarantine_path, rel_dir)))
+                # os.makedirs(quarantine_file_copy_dir, exist_ok=True)
+
+                # Full quarantine path
+                quarantine_file_path = os.path.join(normalize_path(os.path.join(quarantine_file_copy_dir, source_file)))
+
+                # Full destination path (but don't create directory yet)
+                destination_file_copy_dir = os.path.join(normalize_path(os.path.join(destination_path, rel_dir)))
+                destination_file_path = os.path.join(normalize_path(os.path.join(destination_file_copy_dir, source_file)))
+
+                # Copy the file to the appropriate directory in the quarantine directory
+                # quarantine_temp_path = os.path.join(quarantine_file_path + '.tmp')
+
+                try:
+                    copy_temp_then_rename(source_file_path, quarantine_file_path)
+
+                    # if os.path.exists(quarantine_temp_path):
+                    #     os.remove(quarantine_temp_path)
+
+                    # shutil.copy2(source_file_path, quarantine_temp_path)
+                    # os.rename(quarantine_temp_path, quarantine_file_path)
+
+                    # logger.info(f"Copied file {source_file_path} to quarantine: {quarantine_file_path}")
+
+                    # Add to processing queue with full paths
+                    quarantine_files.append((
+                        quarantine_file_path,     # full path to quarantine file
+                        source_file_path,         # full path to source file
+                        destination_file_path,     # full path to destination file
+                        hazard_archive_path,
+                        hazard_encryption_key_file_path,
+                        delete_source_files
+                    ))
+                    
+                except Exception as e:
+                    logger.error(f"Failed to copy file from source: {source_file_path} to quarantine: {quarantine_file_path}. Error: {e}")
+
+
+        # Process files in parallel using a ProcessPoolExecutor with graceful shutdown
+        with ProcessPoolExecutor(max_workers=max_scan_threads) as executor:
+            try:
+                results = list(executor.map(scan_and_process_file, quarantine_files))
+            except Exception as e:
+                logger.error(f"An error occurred during parallel processing: {e}")
+                executor.shutdown(wait=False, cancel_futures=True)
+                raise
+
+        # Check if all files were processed successfully
+        if not all(results):
+            logger.error(f"Some files failed to be processed.")
+
+        # After processing all files, remove contents of quarantine directory
+        remove_directory_contents(quarantine_path)
+
+        # clean up empty subdirectories
+        #  this can be made more efficient
+
+        if(delete_source_files):
+
+            directories_to_remove = []
+
+            for counter, file_transfer in enumerate(quarantine_files):
+                if counter >= len(results):
+                    break
+
+                #transfer was successful, clean up empty directorues
+
+                if results[counter]:
+
+                    source_file_dir = os.path.dirname( quarantine_files[counter][1]) ## source_file_path
+
+                    if ( normalize_path(source_file_dir) == normalize_path(source_path) ):
+                        continue
+
+                    if not source_file_dir in directories_to_remove:
+
+                        if not os.path.exists(source_file_dir):
+                            continue
+
+                        directories_to_remove.append(source_file_dir)
+            
+            for directory_to_remove in directories_to_remove:
+
+                # this won't remove directories that contain subdirectories from which no files were tranferred
+                # remove_empty_directories() will remove recursively remove subfolders
+                if len(os.listdir(directory_to_remove)) == 0:
+                    if not remove_directory(directory_to_remove):
+                        logger.error(f"Could not remove directory during cleanup: {directory_to_remove}")
+                    else:
+                        logger.info(f"Directory removed during cleanup: {directory_to_remove}")
+
+
+    except Exception as e:
+        logger.error(f"Failed to copy files to quarantine: Error: {e}")
+
+
+def remove_empty_directories(root, keep_root = False):
+
+    for path, _, _ in os.walk(root, topdown=False):  # Listing the files
+        if keep_root and path == root:
+            break
+        try:
+            os.rmdir(path)
+        except OSError as ex:
+            print(ex)
+
+def remove_directory(path):
+    try:
+        os.rmdir(path)
+        return True
+    except OSError as ex:
+        print(ex)
+        return False
+
+def remove_directory_contents(root):
+
+    for filename in os.listdir(root):
+        file_path = os.path.join(root, filename)
+        try:
+            if os.path.isfile(file_path) or os.path.islink(file_path):
+                os.unlink(file_path)
+            elif os.path.isdir(file_path):
+                shutil.rmtree(file_path)
+        except Exception as e:
+            print('Failed to delete %s. Reason: %s' % (file_path, e))
+
 def main():
     # Set up argument parser
     parser = argparse.ArgumentParser(description='File Transfer Script')
@@ -534,7 +717,7 @@ def main():
     parser.add_argument('-TestSourceWriteAccess', action='store_true', help='Test write access to the source directory')
     parser.add_argument('-DeleteSourceFilesAfterCopying', action='store_true',
                         help='Delete the source files after copying them to the destination')
-    parser.add_argument('--max-scans', type=int, help='Maximum number of parallel scans')
+    parser.add_argument('--MaxScanThreads', type=int, help='Maximum number of parallel scans')
     parser.add_argument('--lock-file', default='/tmp/shuttle.lock', help='Path to lock file to prevent multiple instances')
     parser.add_argument('-HazardArchivePath', help='Path to the hazard archive directory')
     parser.add_argument('-HazardEncryptionKeyPath', help='Path to the GPG public key file for encrypting hazard files')
@@ -566,12 +749,12 @@ def main():
                 return default
 
         # Get paths and parameters from arguments or settings file
-        source_path = get_setting(args.SourcePath, 'Paths', 'SourcePath')
-        destination_path = get_setting(args.DestinationPath, 'Paths', 'DestinationPath')
-        quarantine_path = get_setting(args.QuarantinePath, 'Paths', 'QuarantinePath')
-        log_path = get_setting(args.LogPath, 'Paths', 'LogPath')
-        hazard_archive_path = get_setting(args.HazardArchivePath, 'Paths', 'HazardArchivePath')
-        log_level_str = get_setting(args.LogLevel, 'Logging', 'LogLevel', 'INFO').upper()
+        source_path = get_setting(args.SourcePath, 'paths', 'source_path')
+        destination_path = get_setting(args.DestinationPath, 'paths', 'destination_path')
+        quarantine_path = get_setting(args.QuarantinePath, 'paths', 'quarantine_path')
+        log_path = get_setting(args.LogPath, 'paths', 'log_path')
+        hazard_archive_path = get_setting(args.HazardArchivePath, 'paths', 'hazard_archive_path')
+        log_level_str = get_setting(args.LogLevel, 'logging', 'log_level', 'INFO').upper()
 
         # Map the log level string to a logging level
         numeric_level = getattr(logging, log_level_str, None)
@@ -597,7 +780,7 @@ def main():
         # Check for required external commands
         import shutil
 
-        required_commands = ['lsof', 'mdatp', 'zip']
+        required_commands = ['lsof', 'mdatp', 'gpg']
         missing_commands = []
 
         for cmd in required_commands:
@@ -611,7 +794,7 @@ def main():
 
         # Get encryption key file path
         if hazard_archive_path:
-            hazard_encryption_key_file_path = args.HazardEncryptionKeyPath or config.get('Paths', 'HazardEncryptionKeyPath', fallback=None)
+            hazard_encryption_key_file_path = args.HazardEncryptionKeyPath or config.get('paths', 'hazard_encryption_key_path', fallback=None)
             if not hazard_encryption_key_file_path:
                 logger.error("Hazard archive path specified but no encryption key file provided")
                 sys.exit(1)
@@ -624,12 +807,12 @@ def main():
 
         # Retrieve other settings
 
-        delete_source_files = args.DeleteSourceFilesAfterCopying or config.getboolean('Settings', 'DeleteSourceFilesAfterCopying', fallback=False)
+        delete_source_files = args.DeleteSourceFilesAfterCopying or config.getboolean('settings', 'delete_source_files_after_copying', fallback=False)
 
-        if args.max_scans is not None:
-            max_scans = args.max_scans
+        if args.MaxScanThreads is not None:
+            max_scan_threads = args.MaxScanThreads
         else:
-            max_scans = config.getint('Settings', 'MaxScans', fallback=2)
+            max_scan_threads = config.getint('settings', 'max_scan_threads', fallback=2)
 
         # Validate required paths
         if not (source_path and destination_path and quarantine_path):
@@ -640,122 +823,24 @@ def main():
         logger.info(f"DestinationPath: {destination_path}")
         logger.info(f"QuarantinePath: {quarantine_path}")
 
-        try:
-            # Create quarantine directory if it doesn't exist
-            os.makedirs(quarantine_path, exist_ok=True)
-
-            # Copy files from source to quarantine directory
-            # os.walk traverses the directory tree
-            for root, dirs, files in os.walk(source_path):
-                for file in files:
-                    file_path = os.path.join(root, file)
-
-                    # Skip files that are not stable (still being written to)
-                    if not is_file_stable(file_path):
-                        print(f"Skipping file {file_path} because it may still be written to.")
-                        continue  # Skip this file and proceed to the next one
-
-                    # Skip files that are currently open
-                    if is_file_open(file_path):
-                        print(f"Skipping file {file_path} because it is being written to.")
-                        continue  # Skip this file and proceed to the next one
-
-                    # Determine the relative directory structure
-                    # Replicate that structure in the quarantine directory
-                    rel_dir = os.path.relpath(root, source_path)
-                    quarantine_file_copy_dir = os.path.join(quarantine_path, rel_dir)
-                    os.makedirs(quarantine_file_copy_dir, exist_ok=True)
-
-                    # Copy the file to the appropriate directory in the quarantine directory
-                    quarantine_temp_path = os.path.join(quarantine_file_copy_dir, file + '.tmp')
-                    try:
-                        shutil.copy2(file_path, quarantine_temp_path)
-                        os.rename(quarantine_temp_path, os.path.join(quarantine_file_copy_dir, file))
-                    except:
-                        if os.path.exists(quarantine_temp_path):
-                            os.remove(quarantine_temp_path)
-                        raise
-
-                    try:
-                        ##shutil.copy2(file_path, quarantine_file_path)
-                        shutil.copy2(file_path, quarantine_file_copy_dir)
-                        logger.info(f"Copied file {file_path} to quarantine: {quarantine_file_copy_dir}")
-                    except FileNotFoundError as e:
-                        logger.error(f"File not found during copying: {file_path} to quarantine: {quarantine_file_copy_dir}. Error: {e}")
-                    except PermissionError as e:
-                        logger.error(f"Permission denied when copying file: {file_path} to quarantine: {quarantine_file_copy_dir}. Error: {e}")
-                    except Exception as e:
-                        logger.error(f"Failed to copy file to quarantine: {file_path} to quarantine: {quarantine_file_copy_dir}. Error: {e}")
-
-            print(f"Successfully copied files from {source_path} to {quarantine_path}")
-        except Exception as e:
-            print(f"Failed to copy files from {source_path} to {quarantine_path}. Error: {e}")
-            sys.exit(1)
-
-        # Prepare arguments for scanning and processing files
-        quarantine_files = []
-        for root, dirs, files in os.walk(source_path):
-            for file in files:
-                # Full paths
-                source_file_path = os.path.join(root, file)
-                
-                # Get relative path to maintain structure
-                rel_dir = os.path.relpath(root, source_path)
-                
-                # Create quarantine directory structure
-                quarantine_dir = os.path.join(quarantine_path, rel_dir)
-                os.makedirs(quarantine_dir, exist_ok=True)
-                
-                # Full quarantine path
-                quarantine_file_path = os.path.join(quarantine_dir, file)
-                
-                # Full destination path (but don't create directory yet)
-                destination_dir = os.path.join(destination_path, rel_dir)
-                destination_file_path = os.path.join(destination_dir, file)
-
-                # Copy to quarantine
-                try:
-                    shutil.copy2(source_file_path, quarantine_file_path)
-                    logger.info(f"Copied file {source_file_path} to quarantine: {quarantine_file_path}")
-                    
-                    # Add to processing queue with full paths
-                    quarantine_files.append((
-                        quarantine_file_path,     # full path to quarantine file
-                        source_file_path,         # full path to source file
-                        destination_file_path,     # full path to destination file
-                        hazard_archive_path,
-                        hazard_encryption_key_file_path,
-                        delete_source_files
-                    ))
-                except FileNotFoundError as e:
-                    logger.error(f"File not found during copying: {source_file_path}. Error: {e}")
-                except PermissionError as e:
-                    logger.error(f"Permission denied when copying file: {source_file_path}. Error: {e}")
-                except Exception as e:
-                    logger.error(f"Failed to copy file to quarantine: {source_file_path}. Error: {e}")
-
-        # Process files in parallel using a ProcessPoolExecutor with graceful shutdown
-        with ProcessPoolExecutor(max_workers=max_scans) as executor:
-            try:
-                results = list(executor.map(scan_and_process_file, quarantine_files))
-            except Exception as e:
-                logger.error(f"An error occurred during parallel processing: {e}")
-                executor.shutdown(wait=False, cancel_futures=True)
-                raise
-
-        # Check if all files were processed successfully
-        if not all(results):
-            print("Some files failed to be processed.")
-
-        # After processing all files, remove the quarantine directory
-        shutil.rmtree(quarantine_path, ignore_errors=True)
+        
+        scan_and_process_directory(
+            source_path,
+            destination_path,
+            quarantine_path,
+            hazard_archive_path,
+            hazard_encryption_key_file_path,
+            delete_source_files,
+            max_scan_threads
+            )
 
     except Exception as e:
         logger.error(f"An error occurred: {e}")
+
     finally:
         # Remove the lock file upon script completion or error
         if os.path.exists(args.lock_file):
             os.remove(args.lock_file)
 
 if __name__ == '__main__':
-    main()
\ No newline at end of file
+    main()
diff --git a/user-check-linux.py b/user-check-linux.py
index 8cb0326..6a520a3 100644
--- a/user-check-linux.py
+++ b/user-check-linux.py
@@ -40,7 +40,9 @@ def get_user_info():
     print(f"Home directory: {home_directory}")
     print(f"Whoami output: {whoami_output}")
 
-def check_access_to_paths(settings_file='settings.txt'):
+def check_access_to_paths(settings_file='~/.shuttle/settings.ini'):
+
+    settings_file = os.path.expanduser(settings_file)
     # Read settings from the file
     settings = {}
     if os.path.exists(settings_file):
@@ -93,7 +95,8 @@ def check_access_to_paths(settings_file='settings.txt'):
         print("\nUser may not have sufficient access to some paths.")
 
 if __name__ == "__main__":
+
     print("User Information:")
     get_user_info()
-    print("\nChecking access to paths in settings.txt:")
+    print("\nChecking access to paths in ~/.shuttle/settings.ini:")
     check_access_to_paths()
